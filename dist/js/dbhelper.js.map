{"version":3,"sources":["dbhelper.js"],"names":["DBPromise","formatSingleRestaurantData","r","Object","assign","photograph","id","formatRestaurantsData","restaurants","map","idb","open","db","oldVersion","createObjectStore","keyPath","store","createIndex","DBHelper","_classCallCheck","this","neighborhoods","callback","_this","then","length","transaction","objectStore","index","getAll","data","catch","_this2","err","_this3","cuisines","fetch","DATABASE_URL","res","json","tx","forEach","d","put","complete","setLocalData","error","_this4","details","get","Number","_this5","restaurant","_defineProperty","cuisine","fetchRestaurants","results","filter","cuisine_type","neighborhood","v","i","uniqueNeighborhoods","indexOf","uniqueCuisines","name","ext","_restaurant$photograp","split","_restaurant$photograp2","_slicedToArray","google","maps","Marker","position","latlng","title","url","urlForRestaurant","animation","Animation","DROP","_restaurant$photograp3","_restaurant$photograp4","filename","jpeg","createElement","imageUrlForRestaurant","webp","document","setAttribute","fallback"],"mappings":"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","file":"dbhelper.js","sourcesContent":["let DBPromise;\n\n(() => {\n  DBPromise = openIDB();\n\n  function openIDB() {\n    return idb.open('restaurant-app', 3, db => {\n      switch (db.oldVersion) {\n        case 0: {\n          // Create table 'restaurants', primary key is id\n          const store = db.createObjectStore('restaurants', {\n            keyPath: 'id'\n          });\n          // if index is needed, put down below\n          store.createIndex('by-name', 'name');\n        }\n\n        case 1: {\n          // eslint-disable-line\n          db.createObjectStore('cuisines');\n          db.createObjectStore('neighborhoods');\n        }\n\n        case 2: {\n          // eslint-disable-line\n          db.createObjectStore('detail', { keyPath: 'id' });\n        }\n      }\n    });\n  }\n})();\n\n/**\n * photograph no longer return 1.jpg\n in api returns 1, so format data here\n also the last one doesn't have, using id to replace\n * @param r\n * @returns {{} & any & {photograph: string}}\n */\nfunction formatSingleRestaurantData(r) {\n  return Object.assign({}, r, {\n    photograph: r.photograph ? `${r.photograph}.jpg` : `${r.id}.jpg`\n  });\n}\n\n/**\n * Format restaurants array data\n * @param restaurants\n */\nfunction formatRestaurantsData(restaurants) {\n  return restaurants.map(formatSingleRestaurantData);\n}\n\n/**\n * Common database helper functions.\n */\nclass DBHelper {\n  // eslint-disable-line no-unused-vars\n\n  constructor() {\n    this.restaurants = [];\n    this.neighborhoods = [];\n    this.cuisines = [];\n    this.details = {};\n  }\n\n  /**\n   * Database URL.\n   * Change this to restaurants.json file location on your server.\n   */\n  static get DATABASE_URL() {\n    const port = 1337; // Change this to your server port\n    return `http://localhost:${port}/restaurants`;\n  }\n\n  static setLocalData(restaurants) {\n    this.restaurants = restaurants;\n  }\n\n  static fetchRestaurantsFromCache(callback) {\n    return DBPromise.then(db => {\n      // only fetch from db once\n      if (!db || (this.restaurants && this.restaurants.length)) {\n        return;\n      }\n\n      const tx = db.transaction('restaurants');\n      const store = tx.objectStore('restaurants').index('by-name');\n      return store\n        .getAll()\n        .then(data => callback(null, data))\n        .catch(err => callback(err, null));\n    });\n  }\n\n  static fetchNeighborhoodsFromCache(callback) {\n    return DBPromise.then(db => {\n      // only fetch from db once\n      if (!db || (this.resneighborhoodstaurants && this.neighborhoods.length)) {\n        return;\n      }\n\n      const tx = db.transaction('neighborhoods');\n      const store = tx.objectStore('neighborhoods');\n      return store\n        .getAll()\n        .then(data => callback(null, data))\n        .catch(err => callback(err, null));\n    });\n  }\n\n  static fetchCuisinesFromCache(callback) {\n    return DBPromise.then(db => {\n      // only fetch from db once\n      if (!db || (this.cuisines && this.cuisines.length)) {\n        return;\n      }\n\n      const tx = db.transaction('cuisines');\n      const store = tx.objectStore('cuisines');\n      return store\n        .getAll()\n        .then(data => callback(null, data))\n        .catch(err => callback(err, null));\n    });\n  }\n\n  /**\n   * Fetch all restaurants.\n   */\n  static fetchRestaurants(callback) {\n    if (this.restaurants && this.restaurants.length) {\n      return this.restaurants;\n    }\n\n    fetch(DBHelper.DATABASE_URL)\n      .then(res => res.json())\n      .then(formatRestaurantsData)\n      .then(data => {\n        DBPromise.then(db => {\n          const tx = db.transaction('restaurants', 'readwrite');\n          const store = tx.objectStore('restaurants');\n          data && data.forEach(d => store.put(d));\n          return tx.complete;\n        });\n        return data;\n      })\n      .then(restaurants => callback(null, restaurants))\n      .then(restaurants => DBHelper.setLocalData(restaurants))\n      .catch(error => callback(error, null));\n  }\n\n  static fetchRestaurantByIdFromCache(id, callback) {\n    return DBPromise.then(db => {\n      // only fetch from db once\n      if (!db || (this.details && this.details[id])) {\n        return;\n      }\n\n      const tx = db.transaction('detail');\n      const store = tx.objectStore('detail');\n      return store\n        .get(Number(id))\n        .then(data => {\n          callback(null, data);\n        })\n        .catch(err => callback(err, null));\n    });\n  }\n\n  /**\n   * Fetch a restaurant by its ID.\n   */\n  static fetchRestaurantById(id, callback) {\n    fetch(`${DBHelper.DATABASE_URL}/${id}`)\n      .then(res => res.json())\n      .then(formatSingleRestaurantData)\n      .then(restaurant => {\n        DBPromise.then(db => {\n          const tx = db.transaction('detail', 'readwrite');\n          const store = tx.objectStore('detail');\n          store.put(restaurant);\n          return tx.complete;\n        });\n        this.details = Object.assign({}, this.details, { [id]: restaurant });\n        return restaurant;\n      })\n      .then(restaurant => {\n        if (restaurant) {\n          // Got the restaurant\n          callback(null, restaurant);\n        } else {\n          // Restaurant does not exist in the database\n          callback('Restaurant does not exist', null);\n        }\n      })\n      .catch(error => callback(error, null));\n  }\n\n  /**\n   * Fetch restaurants by a cuisine type with proper error handling.\n   */\n  static fetchRestaurantByCuisine(cuisine, callback) {\n    // Fetch all restaurants  with proper error handling\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Filter restaurants to have only given cuisine type\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch restaurants by a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Filter restaurants to have only given neighborhood\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByCuisineAndNeighborhood(\n    cuisine,\n    neighborhood,\n    callback\n  ) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        let results = restaurants;\n        if (cuisine != 'all') {\n          // filter by cuisine\n          results = results.filter(r => r.cuisine_type == cuisine);\n        }\n        if (neighborhood != 'all') {\n          // filter by neighborhood\n          results = results.filter(r => r.neighborhood == neighborhood);\n        }\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch all neighborhoods with proper error handling.\n   */\n  static fetchNeighborhoods(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Get all neighborhoods from all restaurants\n        const neighborhoods = restaurants.map(\n          (v, i) => restaurants[i].neighborhood\n        );\n        // Remove duplicates from neighborhoods\n        const uniqueNeighborhoods = neighborhoods.filter(\n          (v, i) => neighborhoods.indexOf(v) == i\n        );\n\n        DBPromise.then(db => {\n          const tx = db.transaction('neighborhoods', 'readwrite');\n          const store = tx.objectStore('neighborhoods');\n\n          uniqueNeighborhoods &&\n            uniqueNeighborhoods.forEach((d, i) => store.put(d, i));\n        });\n        callback(null, uniqueNeighborhoods);\n      }\n    });\n  }\n\n  /**\n   * Fetch all cuisines with proper error handling.\n   */\n  static fetchCuisines(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Get all cuisines from all restaurants\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type);\n        // Remove duplicates from cuisines\n        const uniqueCuisines = cuisines.filter(\n          (v, i) => cuisines.indexOf(v) == i\n        );\n\n        DBPromise.then(db => {\n          const tx = db.transaction('cuisines', 'readwrite');\n          const store = tx.objectStore('cuisines');\n\n          uniqueCuisines && uniqueCuisines.forEach((d, i) => store.put(d, i));\n        });\n        callback(null, uniqueCuisines);\n      }\n    });\n  }\n\n  /**\n   * Restaurant page URL.\n   */\n  static urlForRestaurant(restaurant) {\n    return `./restaurant.html?id=${restaurant.id}`;\n  }\n\n  /**\n   * Restaurant image URL.\n   */\n  static imageUrlForRestaurant(name, ext) {\n    return `/img/${name}-320_small.${ext}`;\n  }\n\n  /**\n   * Generate name of different size of images\n   */\n  static imageSrcset(restaurant) {\n    const [name, ext] = restaurant.photograph.split('.');\n    return `/img/${name}-320_small.${ext} 400w, /img/${name}-640_medium.${ext} 640w, /img/${name}-800_large.${ext} 800w `;\n  }\n\n  /**\n   * Map marker for a restaurant.\n   */\n  static mapMarkerForRestaurant(restaurant, map) {\n    const marker = new google.maps.Marker({\n      position: restaurant.latlng,\n      title: restaurant.name,\n      url: DBHelper.urlForRestaurant(restaurant),\n      map: map,\n      animation: google.maps.Animation.DROP\n    });\n    return marker;\n  }\n\n  static getSourcesForRestaurant(restaurant) {\n    const [filename, ext] = restaurant.photograph.split('.');\n\n    let jpeg = document.createElement('SOURCE');\n    jpeg.setAttribute(\n      'data-srcset',\n      DBHelper.imageUrlForRestaurant(filename, ext)\n    );\n\n    let webp = document.createElement('SOURCE');\n    webp.setAttribute(\n      'data-srcset',\n      DBHelper.imageUrlForRestaurant(filename, 'webp')\n    );\n    webp.setAttribute('type', 'image/webp');\n\n    let fallback = document.createElement('img');\n    fallback.setAttribute(\n      'data-srcset',\n      DBHelper.imageUrlForRestaurant(filename, ext)\n    );\n\n    return [webp, jpeg, fallback];\n  }\n}\n"]}